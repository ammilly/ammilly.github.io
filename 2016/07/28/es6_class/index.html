<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ES6 Class | Amy's blog</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.3.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=1.3.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ES6 Class</h1><a id="logo" href="/.">Amy's blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">ES6 Class</h1><div class="post-meta">Jul 28, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><blockquote>
<p>从ES6（ES2015）开始，JS提出了类（Class）概念，JS中的类只是JS现有的、基于原型的继承的一种语法包装（语法糖），它能让我们用理简明的语法实现继承。</p>
</blockquote>
<a id="more"></a>
<h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>ES6中的类实际就是一个函数，且正如函数的定义方式有函数声明和函数表达式两种方式一样，类的定义也有两种方式，分别为：</p>
<ul>
<li>类声明</li>
<li>类表达式</li>
</ul>
<h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><p>类声明是定义类的一种方式，使用class关键字后跟一个类名，就可以定义一个类。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="comment">// ..</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="不存在变量提升（hoist）"><a href="#不存在变量提升（hoist）" class="headerlink" title="不存在变量提升（hoist）"></a>不存在变量提升（hoist）</h4><p>类声明和函数声明不同的一点是，函数声明存在变量提升现象，而类声明不会。即，类必须先声明，然后才能使用，否则会抛出<code>ReferenceError</code>异常。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); <span class="comment">// Uncaught ReferenceError: Foo is not defined(...)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种规定的原因与类的继承有关，必须保证子类在父类之后定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Foo = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码不会报错，因为class <code>Bar</code>继承<code>Foo</code>时，<code>Foo</code>已经有定义了。但是，如果存在Class提升，上面代码就会报错，因为Class <code>Bar</code>会被提升到代码头部，而表达式式<code>Foo</code>是不会提升的，所以导致Class <code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>还没有定义。</p>
<h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><p>类表达式就定义类的另外一种方式，就像函数表达式一样，在类表达式中，类名是可有可无的。若定义的类名，则该类名只有的类的内部才可以访问到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方式一</span></div><div class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 方式二：给出类名</span></div><div class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</div><div class="line">    getClassName() &#123;</div><div class="line">        <span class="keyword">return</span> Me.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面方式二定义类的同时给出了类名，此时，<code>Me</code>类名只可以在Class的内部代码可用，指代当前类。MyClass的name属性值为给出的类名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> my = <span class="keyword">new</span> MyClass();</div><div class="line">my.getClassName(); <span class="comment">// Me</span></div><div class="line">Me.name; <span class="comment">// Uncaught ReferenceError: Me is not defined(…)</span></div><div class="line">MyClass.name; <span class="comment">// Me</span></div></pre></td></tr></table></figure>
<p>采用类表达式，可以写出立即执行的Class。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;(<span class="string">'Zhang San'</span>);</div><div class="line"></div><div class="line">person.sayName(); <span class="comment">// Zhang San</span></div></pre></td></tr></table></figure>
<h2 id="类体和方法定义"><a href="#类体和方法定义" class="headerlink" title="类体和方法定义"></a>类体和方法定义</h2><p>类的成员需要定义在一对大括号内<code>{}</code>，大括号内的代码的大括号本身组成了类体。类成员包括类构造器和类方法（包括静态方法和实例方法）。</p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>类体中的代码都强制在严格模式中执行，即默认”use strict”。考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。</p>
<h3 id="构造器（constructor方法）"><a href="#构造器（constructor方法）" class="headerlink" title="构造器（constructor方法）"></a>构造器（constructor方法）</h3><p><code>constructor</code>方法是一个特殊的类方法，它既不是静态方法也不是实例方法，它仅在实例化的时候被调用。一个类只能拥有一个名为<code>constructor</code>的方法，否则会抛出<code>SyntaxError</code>异常。</p>
<p>如果没有定义<code>constructor</code>方法，这个方法会被默认添加，即，不管有没有显示定义，任何一个类都有<code>constructor</code>方法。</p>
<p>子类必须在constructor方法中调用<code>super</code>方法，否则新建实例时会报错。因为子类没有自己的<code>this</code>对象，而是继承父类的<code>this</code>对象，然后对其进行加工，如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> ColorPoint(); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure>
<p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super</code>方法，导致新建实例时报错。</p>
<h3 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h3><p>定义类的方法时，方法名前面不需要加上<code>function</code>关键字。另外，方法之间不需要用逗号分隔，加了会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;&#125;</div><div class="line">    </div><div class="line">    doStuff() &#123;&#125;</div><div class="line">    </div><div class="line">    toString() &#123;&#125;</div><div class="line">    </div><div class="line">    toValue() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类的所有方法都是定义在类的<code>prototype</code>属性上的，上面的写法等同于下面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Bar.prototype = &#123;</div><div class="line">    doStuff() &#123;&#125;,</div><div class="line">    toString() &#123;&#125;,</div><div class="line">    toValue() &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>所以，在类的实例上调用方法，实际上就是调用原型上的方法。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</div><div class="line"></div><div class="line">b.constructor === B.prototype.constructor; <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码中，<code>b</code>是B类的实例，它的<code>constructor</code>方法就是B类原型的<code>constructor</code>方法。<br>由于类的方法都是定义在<code>prototype</code>上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</div><div class="line">    toString() &#123;&#125;,</div><div class="line">    toValue() &#123;&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    toString() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'('</span> + x + <span class="string">', '</span> + y + <span class="string">')'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.keys(Point.prototype); <span class="comment">// []</span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype); <span class="comment">// ["constructor", "toString"]</span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(Point, <span class="string">'toString'</span>);</div><div class="line"><span class="comment">// Object &#123;writable: true, enumerable: false, configurable: true&#125;</span></div></pre></td></tr></table></figure>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><code>static</code>关键字用来定义类的静态方法。静态方法是指那些不需要对类进行实例化，使用类名就可以直接访问的方法。静态方法经常用来作为工具函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> distance(a, b) &#123;</div><div class="line">        <span class="keyword">const</span> dx = a.x - b.x;</div><div class="line">        <span class="keyword">const</span> dy = a.y - b.y;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(dx*dx + dy*dy);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Point(<span class="number">5</span>, <span class="number">5</span>);</div><div class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">10</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(Point.distance(p1, p2));</div></pre></td></tr></table></figure>
<p>静态方法不可以被实例继承，是通过类名直接调用的。但是，父类的静态方法可以被子类继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> classMethod() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Bar.classMethod(); <span class="comment">// "hello"</span></div></pre></td></tr></table></figure>
<p>静态方法也可以用<code>super</code>关键字调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> classMethod() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> classMethod() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.classMethod() + <span class="string">', too'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Bar.classMethod(); <span class="comment">// "hello too"</span></div></pre></td></tr></table></figure>
<h2 id="extends关键字"><a href="#extends关键字" class="headerlink" title="extends关键字"></a>extends关键字</h2><p><code>extends</code>关键字用于实现类之间的继承。子类继承父类，就继承了父类的所有属性和方法。<br><code>extends</code>后面只可以跟一个父类。</p>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p><code>super</code>关键字可以用来调用其父类的构造器或方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123; </div><div class="line">  <span class="keyword">constructor</span>(name) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  speak() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' makes a noise.'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</div><div class="line">  speak() &#123;</div><div class="line">    <span class="keyword">super</span>.speak();</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' roars.'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类的Getter和Setter方法"><a href="#类的Getter和Setter方法" class="headerlink" title="类的Getter和Setter方法"></a>类的Getter和Setter方法</h2><p>与ES5一样，在类内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置取值和赋值方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;&#125;</div><div class="line">    </div><div class="line">    get prop() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'getter'</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    set prop(val) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'setter: '</span> + val);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</div><div class="line"></div><div class="line">foo.prop = <span class="number">1</span>;</div><div class="line"><span class="comment">// setter: 1</span></div><div class="line"></div><div class="line">foo.prop;</div><div class="line"><span class="comment">// "getter"</span></div></pre></td></tr></table></figure>
<p>上面代码中，<code>prop</code>属性有对应 的赋值和取值方法，因此赋值和读取行为都被自定义了。<br>存值和取值方法是设置在属性的descriptor对象上的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(Foo.prototype, <span class="string">'prop'</span>);</div><div class="line"></div><div class="line"><span class="string">"get"</span> <span class="keyword">in</span> descriptor <span class="comment">// true</span></div><div class="line"><span class="string">"set"</span> <span class="keyword">in</span> descriptor <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码中，存值和取值方法是定义在<code>prop</code>属性的描述对象上的，这与ES5一致。</p>
<h2 id="类的Generator方法"><a href="#类的Generator方法" class="headerlink" title="类的Generator方法"></a>类的Generator方法</h2><p>如果类的某个方法名前加上星号（<code>*</code>），就表示这个方法是一个Generator函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(...args) &#123;</div><div class="line">    <span class="keyword">this</span>.args = args;</div><div class="line">  &#125;</div><div class="line">  * [<span class="built_in">Symbol</span>.iterator]() &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> <span class="keyword">this</span>.args) &#123;</div><div class="line">      <span class="keyword">yield</span> arg;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="keyword">new</span> Foo(<span class="string">'hello'</span>, <span class="string">'world'</span>)) &#123;</div><div class="line">  <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"><span class="comment">// hello</span></div><div class="line"><span class="comment">// world</span></div></pre></td></tr></table></figure>
<p>上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个Generator函数。Symbol.iterator方法返回一个Foo类的默认遍历器，<code>for...of</code>循环会自动调用这个遍历器。</p>
</div><div class="tags"><a href="/tags/es6/">es6</a><a href="/tags/es2015/">es2015</a><a href="/tags/class/">class</a></div><div class="post-nav"><a href="/2016/07/27/meta_x-ua-compatible/" class="pre">Meta http-equiv属性值X-UA-Compatible</a><a href="/2016/07/29/express/" class="next">Express</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="widget"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."/></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/express/" style="font-size: 15px;">express</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/visibility/" style="font-size: 15px;">visibility</a> <a href="/tags/opacity/" style="font-size: 15px;">opacity</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/JS/" style="font-size: 15px;">JS</a> <a href="/tags/markable/" style="font-size: 15px;">markable</a> <a href="/tags/double/" style="font-size: 15px;">double</a> <a href="/tags/context/" style="font-size: 15px;">context</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/bash/" style="font-size: 15px;">bash</a> <a href="/tags/win7/" style="font-size: 15px;">win7</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/es2015/" style="font-size: 15px;">es2015</a> <a href="/tags/class/" style="font-size: 15px;">class</a> <a href="/tags/display/" style="font-size: 15px;">display</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/framework/" style="font-size: 15px;">framework</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/permission/" style="font-size: 15px;">permission</a> <a href="/tags/function/" style="font-size: 15px;">function</a> <a href="/tags/hello/" style="font-size: 15px;">hello</a> <a href="/tags/jekyll/" style="font-size: 15px;">jekyll</a> <a href="/tags/theme/" style="font-size: 15px;">theme</a> <a href="/tags/branch/" style="font-size: 15px;">branch</a> <a href="/tags/list/" style="font-size: 15px;">list</a> <a href="/tags/delete/" style="font-size: 15px;">delete</a> <a href="/tags/meta/" style="font-size: 15px;">meta</a> <a href="/tags/X-UA-Compatible/" style="font-size: 15px;">X-UA-Compatible</a> <a href="/tags/http-equiv/" style="font-size: 15px;">http-equiv</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-fei"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/04/25/Differences_Display_vs_Visibility_vs_Opacity/">Display vs Visibility vs Opacity 三者之间的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/11/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/list_delete_branches/">How to list and delete branches</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/express/">Express</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/28/es6_class/">ES6 Class</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/27/meta_x-ua-compatible/">Meta http-equiv属性值X-UA-Compatible</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/27/working_with_git/">Working with Git</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/22/git_clone_multiple_repos/">Win7 Git bash 出现Permission denied (publickey)错误</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/22/es6_function_extentions/">ES6 函数扩展</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/22/copy_paste_in_Windows_git_bash/">如何在Windows git bash中拷贝文件内容</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.3.0" async></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |<a href="/atom.xml">订阅本站</a> |<span>联系博主：<a href="mailto:null" target="_blank" class="fa fa-email"> </a><a href="null" target="_blank" class="fa fa-weibo"></a><a href="null" target="_blank" class="fa fa-github"> </a></span></p><p><span> Copyright &copy;<a href="/." rel="nofollow">Amy Zhao</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span><span><a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> Theme </a>by<a rel="nofollow" target="_blank" href="https://github.com/chaooo"> Charles.</a></span></p></div></div></div><script type="text/javascript" src="/js/search.json.js?v=1.3.0"></script></body></html>